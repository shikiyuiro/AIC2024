<!--
author: ISHIKAWA Yuichiro
-->
## [ABC165F LIS on Tree](https://atcoder.jp/contests/abc165/tasks/abc165_f)

<details><summary> ヒント1 </summary>

与えられたグラフがパスグラフだった場合、通常の数列に関するLISのDP解法を用いることができます。
実はこの問題も列構造のときと同じアルゴリズムを用います。

</details>

<details><summary>  ヒント2 </summary>

頂点 $1$ を頂点とする根付き木をイメージし、頂点 $1$ からすべての頂点へのパスを考えると、実は重複している辺がたくさんあることがわかります。列構造のときのアルゴリズムを観察することで、重複している部分の計算を使いまわせないでしょうか。

</details>

<details><summary> 解説 </summary>

[列構造についてのDPについてはこちらを参照してください。](https://zenn.dev/iharuoru/articles/5b060947221440)

列構造のときのアルゴリズムをよく観察すると、列の途中まででDPを打ち切ってもその列の途中までについての計算結果が正しく得られていることがわかります。

したがって、以下のような方法で、木構造上でDPを行うことができます。  
・根付き木の深さ優先探索を考え、その探索と同時にDPを考える。  
・もし、辺を葉方向に向かって進むなら、通常のDPと同じように計算、DP配列の末尾に追加する(C++ならstd::push_backに対応)  
・もし、辺を根方向に向かって進むなら、計算したDP配列の末尾を消去する(C++ならstd::pop_backに対応)

上のように行うことで、各頂点へ到達したとき、その時点でのDP配列が、頂点 $1$ からその頂点へのパスについての計算結果を表すものになっています。

上のアルゴリズムは、通る頂点が$N$個、通る辺が$N-1$本であり、各操作は一回しか行われないので、その計算量は $\mathrm{O}(N\log N)$ となります。

</details>

<details><summary> 余談 </summary>

上の解説では、LISのDPによる具体的な解法を全く言及していません。今回の問題で用いられている性質は、そのDPがroll-backできるという性質のみです。このことは、今回の問題のLISに限らず、様々な列構造に関する問題にが木構造に適用できることを示唆しています。(<b>roll-backDP</b>とよばれます)

</details>