<!--
author: HARADA Kento
-->
## [ABC288D Range Add Query](https://atcoder.jp/contests/abc288/tasks/abc288_d)

<details><summary> ヒント1 </summary>

「区間への足し引き」という操作のまま考えると、見通しが悪いです。よりシンプルな操作に言い換えられないでしょうか。

</details>

<details><summary> ヒント2 </summary>

$A$ の階差数列を考えましょう。

</details>

<details><summary> ヒント3 </summary>

値を加算できる区間の長さは $K$ で固定されています。このことを利用できないでしょうか。

</details>

<details><summary> 解説 </summary>
まず、典型テクニックとして「区間への操作を点への操作に言い換える」というものがあります。今回は、与えられた数列の階差数列を考えることで、これが達成可能です。

例えば、長さ $6$ の数列 $X$ と、その階差数列 $X'$ について考えます。 $X_2 \sim X_4$ に値 $c$ 加算すると、それぞれの数列は以下のように変化します。  
操作前: $X = (X_0,X_1,X_2,X_3,X_4,X_5)$  
操作前: $X' = (X_1-X_0,X_2-X_1,X_3-X_2,X_4-X_3,X_5-X_4)$  
操作後: $X = (X_0,X_1,X_2+c,X_3+c,X_4+c,X_5)$  
操作後: $X' = (X_1-X_0,(X_2+c)-X_1,(X_3+c)-(X_2+c),(X_4+c)-(X_3+c),X_5-(X_4+c))$  
操作後の $X'$を少し整理すると、以下のような形になります。  
操作後: $X' = (X_1-X_0,X_2-X_1+c,X_3-X_2,X_4-X_3,X_5-X_4-c)$  
以上のように考えると、元の数列では区間への操作だったものが、階差数列上では2点への操作になっていることが分かります。これは、imos法の逆の考え方をしていると捉えれば理解しやすいです。

さらに、値を加算できる区間の長さが $K$ で固定されているので、インデックスを $K$ で割った余りが同じ要素間しか互いに影響を与えません。よって、各要素についてインデックスを $K$ で割った余りごとにグループ分けをして、それぞれ独立で考えることができます。これは、「割った余りでグループ分けして独立に扱う」という典型です。

さて、数列 $(A_l,A_{l+1},...,A_{r})$ が良い数列か判定する方法を考えます。上記のように階差数列を作り、グループ分けをします。すると、操作によって各グループの総和は変わらないことが分かります（同じグループに $+c$ と $-c$ が加算されるため）。そして、各グループの総和が変わらない範囲で自由に値を変更することができます。

以上より、各グループの総和が $0$ であるか判定すれば、その数列が良い数列か判定することができます。総和が $0$ ならば、各要素が $0$ になるように要素の値を変えられるためです。これは、「不変量を考える」という典型テクニックです。

この判定は、累積和を用いると高速に行うことができます。計算量は $\mathrm{O}(N+QK)$です。

実装例 (C++)
```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n,k;
    cin >> n >> k;
    vector<int> a(n);
    for(int i = 0;i < n;i++) cin >> a[i];

    vector<vector<long long>> s(k,vector<long long>(n+1));
    for(int i = 0;i < n;i++) s[i%k][i+1] = a[i];
    for(int i = 0;i < k;i++)for(int j = 0;j < n;j++) s[i][j+1] += s[i][j];

    int q;
    cin >> q;
    for(int qi = 0;qi < q;qi++){
        int l,r;
        cin >> l >> r;
        l--;
        vector<long long> ns(k);
        for(int i = 0;i < k;i++) ns[i] = s[i][r]-s[i][l];
        sort(ns.begin(),ns.end());
        if(ns[0] == ns.back()) cout << "Yes" << endl;
        else cout << "No" << endl;
    }
}
```

</details>
