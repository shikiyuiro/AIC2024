<!--
author: ISHIKAWA Yuichiro
-->
## [ARC100E Or Plus Max](https://atcoder.jp/contests/arc125/tasks/arc100_e)

<details><summary> 問題の言い換え1 </summary>

$(i \,or\, j) \leq K$ の代わりに、$(i \,or\, j) = K$ のときに問題が解ければよいです。

</details>

<details><summary> 問題の言い換え2 </summary>

$(i \,or\, j) = K$ の代わりに、$(i \,or\, j\,or\, K) = K$ のとき(すなわち、$(i \,or\, j)$のビットが全て$K$に含まれるとき)に問題が解ければよいです。
上は「$i$のビットがすべて$K$に含まれ、かつ$j$のビットがすべて$K$に含まれている」と、独立に考えてよいです。

</details>

<details><summary> 解説 </summary>

各$K$について、$i$のビットと$j$のビットがすべて$K$に含まれるような組$(i, j)$のなかで、$A_i + A_j$の最大値を求めればよいです。

DPを用いてこの問題を解くことを考えます。  
どのように遷移すればよいでしょうか。  
「$y$が$x$のビットをすべて含むとき$x→y$と遷移する」と定めると、その遷移だけで時間計算量が$\mathrm{O}(3^N)$かかってしまいます。(その手法は[EDPC-Uの解説](https://kyopro-friends.hatenablog.com/entry/2019/01/12/231106)などを参照してください。今回の問題を解く上では不要です。)  
そこで、代わりに以下のようにビットごとに遷移することで、遷移の量を$\mathrm{O}(N \log N)$個まで落とすことができます。
以下に遷移の擬似コードを記述します。ここで、<b>dpの添字は2進数です。</b>
```
1の位に関して遷移(1の位が0である添字から1の位が1である添字へ)
dp[0000] → dp[0001]
dp[0010] → dp[0011]
dp[0100] → dp[0101]
dp[0110] → dp[0111]
dp[1000] → dp[1001]
⋮

そのつぎ、2の位に関して遷移(2の位が0である添字から2の位が1である添字へ)
dp[0000] → dp[0010]
dp[0001] → dp[0011]
dp[0100] → dp[0110]
dp[0101] → dp[0111]
dp[1000] → dp[1010]
⋮

そのつぎ、4の位に関して遷移
⋮
そのつぎ、8の位に関して遷移
⋮

```

この手法は<b>高速ゼータ変換</b>と呼ばれています。　　

なお今回の問題の場合、DP配列に和を直接保持するよりも、{最も大きい$A$の要素, 二番目に大きい$A$の要素}を保持した方が、重複なく数え上げやすいです。

</details>
