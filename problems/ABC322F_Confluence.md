<!--
author: HARADA Kento
-->
## [ABC322F Confluence](https://atcoder.jp/contests/abc183/tasks/abc183_f)

<details><summary> ヒント1 </summary>

何も思いつかない方は、一旦UnionFindの仕組みについて調べてみましょう。

</details>

<details><summary> ヒント2 </summary>

「データ構造をマージする一般的なテク」、略して「マージテク」を使います。

</details>

<details><summary> 解説 </summary>

$cnt[i][j] = (生徒iが所属しているグループの中で、クラスjに属する人の人数)$とします。この情報をmapやdictで持っていれば、タイプ2のクエリの答えは $cnt[x][y]$ であるため、高速に答えることができます。しかし、これを全ての生徒について持っているとメモリが足りないので、まずはこのデータを効率よく管理する方法を考えます。  

生徒全員についてこのデータを持つ必要は無く、一つのグループにつき代表者一人だけが持っていれば良いです。例えば、生徒 $1, 2, 3$ が同じグループにいるときは、生徒 $1$ を代表者として $cnt[1][j] = (生徒1が所属しているグループの中で、クラスjに属する人の人数)$ というデータを管理することにします。生徒 $2,3$ については、「生徒 $1$ を参照する」という情報を持っておけば良いです。「誰を参照するか」という情報は、例えば $p[i] = (生徒iの参照先)$ のような配列を作ることで高速に求めることができます。先程の例だと、$p[1] = 1, p[2] = 1, p[3] = 1$ です。

続いて、クエリ1をどのように処理するか考えます。グループ同士を合流させる際、$g[i] = (生徒iが所属しているグループのメンバー一覧)$ も必要になるので、これも管理しておきます（$cnt$ と同様、グループの代表者だけに持たせます）。さて、サイズ $a$ のグループ $A$ とサイズ $b$ のグループ $B$ を合流させるとき、先程の $cnt$ 配列、 $p$ 配列、$g$ 配列を愚直に更新すると、$A$ を $B$ に合流させる場合の計算量は $\Theta{(a\log N)}$、$B$ を $A$ に合流させる場合の計算量は $\Theta{(b\log N)}$ となります。

合流1回で最大 $\Theta{(N \log N)}$ かかるため、愚直に配列を更新していては間に合わないように見えます。しかし、実は「サイズの小さいグループをサイズの大きいグループの合流させる」という工夫をするだけで、合流にかかる計算量が全体で $\mathrm{O}(N (\log N)^2)$ になります。この理由については、[データ構造をマージする一般的なテクについての解説記事](https://web.archive.org/web/20181213115442/http://topcoder.g.hatena.ne.jp/iwiwi/20131226/1388062106) を参照してください。「マージテク」や「Union by size」というキーワードで調べても良いと思います。

以上より、この問題を$\mathrm{O}(N (\log N)^2+Q\log N)$ で解くことが出来ました。

[実装例(C++)](https://atcoder.jp/contests/abc183/submissions/54713866)  
[実装例(Python)](https://atcoder.jp/contests/abc183/submissions/54741638)

</details>
